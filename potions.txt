Гра вже виглядає досить комплексною! У нас є різні типи перешкод, механіка "підземелля" та кисень.

Щоб зробити гру ще цікавішою, я пропоную додати **Бонусний предмет (Синє зілля/Blue Potion)**.

**Як це працює:**
1.  Він з'являється на полі випадковим чином на короткий час (наприклад, на 5 секунд).
2.  Якщо його з'їсти — він **повністю відновлює кисень** і дає **+5 очок**.
3.  Це додає азарту: гравець ризикує, намагаючись встигнути схопити бонус, поки той не зник.

Тобі знадобиться картинка `potion.png` у папці `assets/images/`.

Ось код:

### 1. `food.py`
Додамо клас `Bonus`. Він має таймер життя (`timer`).

```python
import random
import pygame # Потрібно для get_ticks

class Food:
    def __init__(self):
        self.position = (0, 0)

    def place(self, snake_body, rock_positions, palm_positions, rows, cols):
        while True:
            r = random.randint(0, rows - 1)
            c = random.randint(0, cols - 1)
            pos = (r, c)
            if pos not in [s["pos"] for s in snake_body] and \
               pos not in rock_positions and \
               pos not in palm_positions:
                self.position = pos
                break

class Rocks:
    def __init__(self, count):
        self.positions = []
        self.count = count

    def place(self, snake_body, rows, cols):
        self.positions = []
        attempts = 0
        while len(self.positions) < self.count and attempts < 1000:
            attempts += 1
            r = random.randint(0, rows - 1)
            c = random.randint(0, cols - 1)
            head_safe_zone = [(snake_body[0]["pos"][0] + i, snake_body[0]["pos"][1] + j) for i in range(-3, 4) for j in range(-3, 4)]
            pos = (r, c)
            if pos not in [s["pos"] for s in snake_body] and pos not in self.positions and pos not in head_safe_zone:
                self.positions.append(pos)

class Palms:
    def __init__(self, count):
        self.positions = []
        self.count = count

    def place(self, snake_body, rock_positions, rows, cols):
        self.positions = []
        attempts = 0
        while len(self.positions) < self.count and attempts < 1000:
            attempts += 1
            r = random.randint(0, rows - 1)
            c = random.randint(0, cols - 1)
            head_safe_zone = [(snake_body[0]["pos"][0] + i, snake_body[0]["pos"][1] + j) for i in range(-3, 4) for j in range(-3, 4)]
            pos = (r, c)
            if pos not in [s["pos"] for s in snake_body] and pos not in rock_positions and pos not in self.positions and pos not in head_safe_zone:
                self.positions.append(pos)

# --- НОВИЙ КЛАС БОНУСУ ---
class Bonus:
    def __init__(self):
        self.position = None # None означає, що бонуса зараз немає на полі
        self.spawn_time = 0
        self.duration = 5000 # Скільки часу лежить бонус (5 сек)
        self.last_attempt = 0
        self.cooldown = 10000 # Як часто пробувати спавнити (10 сек)

    def update(self, current_time, snake_body, rocks, palms, food_pos, rows, cols):
        # Якщо бонус активний, перевіряємо, чи не вийшов час
        if self.position:
            if current_time - self.spawn_time > self.duration:
                self.position = None # Бонус зникає
        else:
            # Якщо бонуса немає, пробуємо створити
            if current_time - self.last_attempt > self.cooldown:
                self.last_attempt = current_time
                # 30% шанс появи
                if random.random() < 0.3: 
                    self.place(snake_body, rocks, palms, food_pos, rows, cols)

    def place(self, snake_body, rocks, palms, food_pos, rows, cols):
        while True:
            r = random.randint(0, rows - 1)
            c = random.randint(0, cols - 1)
            pos = (r, c)
            # Перевірка на всі перешкоди та їжу
            if pos not in [s["pos"] for s in snake_body] and \
               pos not in rocks and \
               pos not in palms and \
               pos != food_pos:
                self.position = pos
                self.spawn_time = pygame.time.get_ticks()
                break
```

### 2. `snake.py`
Додаємо обробку бонусу: картинка, оновлення, поїдання.

```python
import pygame
import os
from settings import *
from food import Food, Rocks, Palms, Bonus # Імпортуємо Bonus

class Snake:
    def __init__(self, difficulty_settings, sound_enabled=True):
        self.high_score = 0
        self.sound_enabled = sound_enabled
        
        self.cell_size = difficulty_settings["cell"]
        self.rock_count = difficulty_settings["rocks"]
        self.palm_count = difficulty_settings["palms"]
        
        self.rows = WINDOW_H // self.cell_size
        self.cols = WINDOW_W // self.cell_size
        
        try:
            self.snd_eat = pygame.mixer.Sound("assets/sounds/apple_eat.wav")
            self.snd_lose = pygame.mixer.Sound("assets/sounds/lose.wav")
            # Можна додати звук бонусу
            # self.snd_bonus = pygame.mixer.Sound("assets/sounds/bonus.wav")
            self.snd_eat.set_volume(0.5)
            self.snd_lose.set_volume(0.5)
        except Exception as e:
            print(f"Sounds error: {e}")
            self.snd_eat = None
            self.snd_lose = None

        # Картинки
        self.img_head = pygame.image.load("assets/images/head.png").convert_alpha()
        self.img_body = pygame.image.load("assets/images/body.png").convert_alpha()
        self.img_tail = pygame.image.load("assets/images/tail.png").convert_alpha()
        self.img_apple = pygame.image.load("assets/images/apple.png").convert_alpha()
        self.img_rock = pygame.image.load("assets/images/rock.png").convert_alpha()
        self.img_palma = pygame.image.load("assets/images/palma.png").convert_alpha()
        
        # Завантажуємо картинку зілля
        # Якщо у тебе немає potion.png, код буде використовувати синє коло
        try:
            self.img_bonus = pygame.image.load("assets/images/potion.png").convert_alpha()
        except:
            self.img_bonus = None # Будемо малювати кружечком, якщо немає картинки

        self.turn_images = {
            "turn_ul": pygame.image.load("assets/images/turn_ul.png").convert_alpha(),
            "turn_ur": pygame.image.load("assets/images/turn_ur.png").convert_alpha(),
            "turn_dl": pygame.image.load("assets/images/turn_dl.png").convert_alpha(),
            "turn_dr": pygame.image.load("assets/images/turn_dr.png").convert_alpha(),
        }
        
        self.food = Food()
        self.rocks = Rocks(self.rock_count)
        self.palms = Palms(self.palm_count)
        self.bonus = Bonus() # Створюємо бонус
        
        self.reset()

    def reset(self):
        mid_r = self.rows // 2
        mid_c = self.cols // 2

        self.body = [
            {"pos": (mid_r, mid_c), "type": "straight"},
            {"pos": (mid_r, mid_c - 1), "type": "straight"},
            {"pos": (mid_r, mid_c - 2), "type": "straight"},
        ]

        self.dir = (0, 1)
        self.next_dir = (0, 1)
        self.score = 0
        self.game_over = False
        
        self.is_diving = False
        self.oxygen_max = BASE_FPS * 5 
        self.oxygen = self.oxygen_max

        self.rocks.place(self.body, self.rows, self.cols)
        self.palms.place(self.body, self.rocks.positions, self.rows, self.cols)
        self.food.place(self.body, self.rocks.positions, self.palms.positions, self.rows, self.cols)
        self.bonus.position = None # Скидаємо бонус

    def toggle_dive(self):
        if self.is_diving:
            self.is_diving = False
        else:
            if self.oxygen > self.oxygen_max * 0.1:
                self.is_diving = True

    def game_over_logic(self):
        if not self.game_over and self.snd_lose and self.sound_enabled:
            self.snd_lose.play()

        self.game_over = True
        if self.score > self.high_score:
            self.high_score = self.score

    def update(self):
        if self.game_over:
            return
            
        # --- ОНОВЛЕННЯ БОНУСУ ---
        current_time = pygame.time.get_ticks()
        self.bonus.update(current_time, self.body, self.rocks.positions, 
                          self.palms.positions, self.food.position, self.rows, self.cols)

        if self.is_diving:
            self.oxygen -= 1
            if self.oxygen <= 0:
                self.oxygen = 0
                self.is_diving = False
        else:
            if self.oxygen < self.oxygen_max:
                self.oxygen += 0.5

        if self.next_dir != (-self.dir[0], -self.dir[1]):
            prev = self.dir
            self.dir = self.next_dir
            turn = self.get_turn_type(prev, self.dir)
            if turn:
                self.body[0]["type"] = turn

        head_r, head_c = self.body[0]["pos"]
        dr, dc = self.dir
        new_head = (head_r + dr, head_c + dc)

        if not (0 <= new_head[0] < self.rows and 0 <= new_head[1] < self.cols):
            self.game_over_logic()
            return

        if self.is_diving:
            if new_head in self.palms.positions:
                self.game_over_logic()
                return
        else:
            if new_head in [s["pos"] for s in self.body] or \
               new_head in self.rocks.positions or \
               new_head in self.palms.positions:
                self.game_over_logic()
                return
        
        self.body.insert(0, {"pos": new_head, "type": "straight"})

        # --- ПЕРЕВІРКА ЇЖІ ---
        if new_head == self.food.position:
            self.score += 1
            if self.snd_eat and self.sound_enabled:
                self.snd_eat.play()
            self.food.place(self.body, self.rocks.positions, self.palms.positions, self.rows, self.cols)
            
        # --- ПЕРЕВІРКА БОНУСУ ---
        elif self.bonus.position and new_head == self.bonus.position:
            self.score += 5 # +5 очок
            self.oxygen = self.oxygen_max # Повний кисень
            self.bonus.position = None # Бонус з'їдений
            # Можна тут теж програти звук self.snd_eat.play()
            if self.snd_eat and self.sound_enabled:
                self.snd_eat.play()
        else:
            self.body.pop()

        if self.body[-1]["type"].startswith("turn"):
            self.body[-1]["type"] = "straight"

    # (Методи rotate, get_turn_type без змін...)
    def get_turn_type(self, prev, new):
        mapping = {
            ((-1,0),(0,-1)):"turn_ul", ((-1,0),(0,1)):"turn_ur",
            ((1,0),(0,-1)):"turn_dl", ((1,0),(0,1)):"turn_dr",
            ((0,-1),(-1,0)):"turn_dr", ((0,-1),(1,0)):"turn_ur",
            ((0,1),(-1,0)):"turn_dl", ((0,1),(1,0)):"turn_ul",
        }
        return mapping.get((prev, new), None)

    def rotate(self, img, direction):
        dr, dc = direction
        if (dr, dc) == (0, 1): angle = -90
        elif (dr, dc) == (1, 0): angle = 180
        elif (dr, dc) == (0, -1): angle = 90
        elif (dr, dc) == (-1, 0): angle = 0
        else: angle = 0
        return pygame.transform.rotate(img, angle)

    def draw_grid(self, surf):
        for r in range(self.rows):
            for c in range(self.cols):
                color = GREEN if (r + c) % 2 == 0 else LIGHT_GREEN
                pygame.draw.rect(surf, color, (c * self.cell_size, r * self.cell_size, self.cell_size, self.cell_size))

    def draw_snake(self, surf):
        alpha = 100 if self.is_diving else 255
        cell = self.cell_size
        for i, seg in enumerate(self.body):
            r, c = seg["pos"]
            x, y = c * cell, r * cell
            img = None
            if i == 0: img = self.rotate(self.img_head, self.dir)
            elif i == len(self.body) - 1:
                prev = self.body[i - 1]["pos"]
                dr = prev[0] - r
                dc = prev[1] - c
                img = self.rotate(self.img_tail, (dr, dc))
            elif seg["type"].startswith("turn"): img = self.turn_images[seg["type"]]
            else:
                prev = self.body[i - 1]["pos"]
                nxt = self.body[i + 1]["pos"]
                if prev[1] == c and nxt[1] == c: img = pygame.transform.rotate(self.img_body, 90)
                else: img = self.img_body
            img_copy = img.copy()
            img_copy.set_alpha(alpha)
            img_copy = pygame.transform.scale(img_copy, (cell, cell))
            surf.blit(img_copy, (x, y))

    def draw_apple(self, surf):
        r, c = self.food.position
        cell = self.cell_size
        img = pygame.transform.scale(self.img_apple, (cell, cell))
        surf.blit(img, (c * cell, r * cell))
        
    # --- МАЛЮВАННЯ БОНУСУ ---
    def draw_bonus(self, surf):
        if self.bonus.position:
            r, c = self.bonus.position
            cell = self.cell_size
            x, y = c * cell, r * cell
            
            if self.img_bonus:
                img = pygame.transform.scale(self.img_bonus, (cell, cell))
                surf.blit(img, (x, y))
            else:
                # Якщо картинки немає - малюємо синій круг
                center = (x + cell//2, y + cell//2)
                pygame.draw.circle(surf, BLUE, center, cell//3)
                pygame.draw.circle(surf, WHITE, center, cell//3, 2)

    def draw_rocks(self, surf):
        cell = self.cell_size
        for pos in self.rocks.positions:
            r, c = pos
            img = pygame.transform.scale(self.img_rock, (cell, cell))
            surf.blit(img, (c * cell, r * cell))

    def draw_palms(self, surf):
        cell = self.cell_size
        for pos in self.palms.positions:
            r, c = pos
            img = pygame.transform.scale(self.img_palma, (cell, cell))
            surf.blit(img, (c * cell, r * cell))
            
    def draw_ui(self, surf):
        bar_width = 200
        bar_height = 20
        x = WINDOW_W - bar_width - 10
        y = 10
        pygame.draw.rect(surf, (50, 50, 50), (x, y, bar_width, bar_height))
        oxygen_ratio = self.oxygen / self.oxygen_max
        if oxygen_ratio < 0: oxygen_ratio = 0
        fill_width = int(bar_width * oxygen_ratio)
        color = BLUE if oxygen_ratio > 0.25 else RED
        pygame.draw.rect(surf, color, (x, y, fill_width, bar_height))
        pygame.draw.rect(surf, WHITE, (x, y, bar_width, bar_height), 2)
        font = pygame.font.SysFont("arial", 14, True)
        text = font.render("OXYGEN", True, WHITE)
        surf.blit(text, (x + 70, y + 2))

    def draw_death_screen(self, surf):
        overlay = pygame.Surface((WINDOW_W, WINDOW_H), pygame.SRCALPHA)
        overlay.fill(DARK_OVERLAY)
        surf.blit(overlay, (0,0))
        font_big = pygame.font.SysFont("arial", 50, True)
        font_small = pygame.font.SysFont("arial", 30, True)
        font_mini = pygame.font.SysFont("arial", 20, True)
        text_game_over = font_big.render("GAME OVER", True, RED)
        text_score = font_small.render(f"Score: {self.score}", True, WHITE)
        text_high = font_small.render(f"High Score: {self.high_score}", True, WHITE)
        text_restart = font_small.render("Press SPACE to Restart", True, WHITE)
        text_menu = font_mini.render("Press ESC to Menu", True, WHITE)
        rect_go = text_game_over.get_rect(center=(WINDOW_W//2, WINDOW_H//2 - 60))
        rect_sc = text_score.get_rect(center=(WINDOW_W//2, WINDOW_H//2))
        rect_hi = text_high.get_rect(center=(WINDOW_W//2, WINDOW_H//2 + 40))
        rect_rs = text_restart.get_rect(center=(WINDOW_W//2, WINDOW_H//2 + 100))
        rect_mn = text_menu.get_rect(center=(WINDOW_W//2, WINDOW_H//2 + 140))
        surf.blit(text_game_over, rect_go)
        surf.blit(text_score, rect_sc)
        surf.blit(text_high, rect_hi)
        surf.blit(text_restart, rect_rs)
        surf.blit(text_menu, rect_mn)

    def draw(self, surf):
        self.draw_grid(surf)
        self.draw_rocks(surf)
        self.draw_palms(surf)
        self.draw_bonus(surf) # Малюємо бонус
        self.draw_apple(surf)
        self.draw_snake(surf)
        if not self.game_over:
            self.draw_ui(surf)
        if self.game_over:
            self.draw_death_screen(surf)
```
